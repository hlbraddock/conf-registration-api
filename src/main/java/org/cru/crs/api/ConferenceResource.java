package org.cru.crs.api;

import java.net.URI;
import java.net.URISyntaxException;
import java.util.List;
import java.util.UUID;

import javax.ejb.Stateless;
import javax.inject.Inject;
import javax.persistence.EntityManager;
import javax.ws.rs.Consumes;
import javax.ws.rs.GET;
import javax.ws.rs.POST;
import javax.ws.rs.PUT;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.Response.Status;

import org.cru.crs.api.optimizer.ConferenceOptimizer;
import org.cru.crs.model.ConferenceEntity;
import org.cru.crs.model.PageEntity;
import org.cru.crs.service.ConferenceService;

import com.google.common.base.Preconditions;

@Stateless
@Path("/conferences")
public class ConferenceResource
{
	@Inject EntityManager em;
	
	/**
	 * Desired design: Gets all the conferences for which the authenticated user has access to.
	 * 
	 * Current status: Returns all conferences in the system.  Need authentication built out to
	 * implement as designed.
	 * 
	 * @return
	 */
	@GET
	@Produces(MediaType.APPLICATION_JSON)
	public List<ConferenceEntity> getConferences()
	{
		List<ConferenceEntity> conferences = new ConferenceService(em).fetchAllConferences();
		for(ConferenceEntity conference : conferences)
		{
			conference = ConferenceOptimizer.removePagesFromConference(conference);
		}
		return conferences;
	}
	
	/**
	 * Desired design: Get conference specified by Id if the user has access to it.
	 * 
	 * Current status: No authentication in place.
	 * @param conferenceId
	 * @return
	 */
	@GET
	@Path("/{conferenceId}")
	@Produces(MediaType.APPLICATION_JSON)
	public Response getConference(@PathParam(value = "conferenceId") UUID conferenceId)
	{
		ConferenceEntity requestedConference = new ConferenceService(em).fetchConferenceBy(conferenceId);
		
		if(requestedConference == null) return Response.status(Status.NOT_FOUND).build();
		
		return Response.ok(requestedConference).build();
	}
	
	/**
	 * Creates a new conference.
	 * 
	 * Preconditions:
	 * -No conference ID.  Conference ID should only be generated by this system, not by an outside system.
	 * @param conference
	 * @return
	 * @throws URISyntaxException
	 */
	@POST
	@Consumes(MediaType.APPLICATION_JSON)
	public Response createConference(ConferenceEntity conference)throws URISyntaxException
	{
		Preconditions.checkState(conference.getId() == null);
		
		conference.setId(UUID.randomUUID());
		
		new ConferenceService(em).createNewConference(conference);
		
		return Response.created(new URI("/conferences/" + conference.getId())).build();
	}
	
	/**
	 * Updates an existing conference
	 * 
	 * Accepts conference ID as a path parameter, but not sure how to use that at first.  It seems
	 * reasonable to assume the conference entity has the ID in it already.
	 * 
	 * Preconditions: the conference already exists and therefore has a valid Id.
	 * @param conference
	 * @return
	 */
	@PUT
	@Path("/{conferenceId}")
	@Consumes(MediaType.APPLICATION_JSON)
	public Response updateConference(ConferenceEntity conference, @PathParam(value = "conferenceId") String conferenceId)
	{
		Preconditions.checkNotNull(conference.getId());
		
		new ConferenceService(em).updateConference(conference);
		
		return Response.noContent().build();
	}
	
	@POST
	@Path("/{conferenceId}/pages")
	@Consumes(MediaType.APPLICATION_JSON)
	public Response createPage(PageEntity newPage, @PathParam(value = "conferenceId") UUID conferenceId) throws URISyntaxException
	{
		if(newPage.getId() == null) newPage.setId(UUID.randomUUID());
		
		ConferenceEntity conference = new ConferenceService(em).fetchConferenceBy(conferenceId);
		
		if(conference == null) return Response.status(Status.BAD_REQUEST).build();
		
		conference.getPages().add(newPage);
		
		return Response.created(new URI("/pages/" + newPage.getId())).build();
	}
}
